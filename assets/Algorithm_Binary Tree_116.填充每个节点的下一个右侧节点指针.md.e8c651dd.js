import{_ as s,o as n,c as a,Q as l}from"./chunks/framework.06b9d6ab.js";const u=JSON.parse('{"title":"LeetCode 116 填充每个节点的下一个右侧节点指针","description":"","frontmatter":{},"headers":[],"relativePath":"Algorithm/Binary Tree/116.填充每个节点的下一个右侧节点指针.md","filePath":"Algorithm/Binary Tree/116.填充每个节点的下一个右侧节点指针.md","lastUpdated":1681811534000}'),e={name:"Algorithm/Binary Tree/116.填充每个节点的下一个右侧节点指针.md"},o=l(`<h1 id="leetcode-116-填充每个节点的下一个右侧节点指针" tabindex="-1"><a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/" target="_blank" rel="noreferrer">LeetCode 116 填充每个节点的下一个右侧节点指针</a> <a class="header-anchor" href="#leetcode-116-填充每个节点的下一个右侧节点指针" aria-label="Permalink to &quot;[LeetCode 116 填充每个节点的下一个右侧节点指针](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/)&quot;">​</a></h1><p>给定一个<strong>完美二叉树</strong>，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">struct Node {</span></span>
<span class="line"><span style="color:#e1e4e8;">  int val;</span></span>
<span class="line"><span style="color:#e1e4e8;">  Node *left;</span></span>
<span class="line"><span style="color:#e1e4e8;">  Node *right;</span></span>
<span class="line"><span style="color:#e1e4e8;">  Node *next;</span></span>
<span class="line"><span style="color:#e1e4e8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">struct Node {</span></span>
<span class="line"><span style="color:#24292e;">  int val;</span></span>
<span class="line"><span style="color:#24292e;">  Node *left;</span></span>
<span class="line"><span style="color:#24292e;">  Node *right;</span></span>
<span class="line"><span style="color:#24292e;">  Node *next;</span></span>
<span class="line"><span style="color:#24292e;">}</span></span></code></pre></div><p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。 初始状态下，所有  next 指针都被设置为 NULL。</p><p><strong>示例 1：</strong><img src="https://assets.leetcode.com/uploads/2019/02/14/116_sample.png" alt="示例1" title="示例1"></p><blockquote><p>输入：root = [1,2,3,4,5,6,7]<br> 输出：[1,#,2,3,#,4,5,6,7,#]<br> 解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化的输出按层序遍历排列，同一层节点由 next 指针连接，&#39;#&#39; 标志着每一层的结束。</p></blockquote><p><strong>示例 2:</strong></p><blockquote><p>输入：root = []<br> 输出：[]</p></blockquote><p>提示：</p><p>树中节点的数量在  [0, 212 - 1]  范围内 -1000 &lt;= node.val &lt;= 1000</p><h2 id="思路" tabindex="-1">思路 <a class="header-anchor" href="#思路" aria-label="Permalink to &quot;思路&quot;">​</a></h2><h3 id="遍历" tabindex="-1">遍历 <a class="header-anchor" href="#遍历" aria-label="Permalink to &quot;遍历&quot;">​</a></h3><p>本题如果采用常规traverse思路遍历，用<code>treeNode1.next = treeNode2</code>将两个节点进行连接，运行完会发现因为它只能把相同父节点的两个节点连起来。</p><p>如果想要连接不同父节点但是“相邻”叶子节点，可以把思路往上“提一提”，将两个叶子节点看成一个大叶子节点，一个深度为2的完美二叉树就可以看成有同一根节点的多叶子节点的树。</p><p>此时我们只需要遍历每个大叶子节点，将大叶子节点中的两个节点连接即可。</p><p>代码如下：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">/**</span></span>
<span class="line"><span style="color:#6A737D;"> * </span><span style="color:#F97583;">@param</span><span style="color:#6A737D;"> </span><span style="color:#B392F0;">{Node}</span><span style="color:#6A737D;"> </span><span style="color:#E1E4E8;">root</span></span>
<span class="line"><span style="color:#6A737D;"> * </span><span style="color:#F97583;">@return</span><span style="color:#6A737D;"> </span><span style="color:#B392F0;">{Node}</span></span>
<span class="line"><span style="color:#6A737D;"> */</span></span>
<span class="line"><span style="color:#F97583;">var</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">connect</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">function</span><span style="color:#E1E4E8;"> (</span><span style="color:#FFAB70;">root</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (root </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">traverse</span><span style="color:#E1E4E8;">(root.left, root.right)</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> root</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"><span style="color:#F97583;">var</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">traverse</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">function</span><span style="color:#E1E4E8;"> (</span><span style="color:#FFAB70;">treeNode1</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">treeNode2</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> ((treeNode1 </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">|</span><span style="color:#E1E4E8;"> (treeNode2 </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">)) </span><span style="color:#F97583;">return</span></span>
<span class="line"><span style="color:#E1E4E8;">  treeNode1.next </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> treeNode2</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">traverse</span><span style="color:#E1E4E8;">(treeNode1.left, treeNode1.right)</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">traverse</span><span style="color:#E1E4E8;">(treeNode2.left, treeNode2.right)</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">traverse</span><span style="color:#E1E4E8;">(treeNode1.right, treeNode2.left)</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">/**</span></span>
<span class="line"><span style="color:#6A737D;"> * </span><span style="color:#D73A49;">@param</span><span style="color:#6A737D;"> </span><span style="color:#6F42C1;">{Node}</span><span style="color:#6A737D;"> </span><span style="color:#24292E;">root</span></span>
<span class="line"><span style="color:#6A737D;"> * </span><span style="color:#D73A49;">@return</span><span style="color:#6A737D;"> </span><span style="color:#6F42C1;">{Node}</span></span>
<span class="line"><span style="color:#6A737D;"> */</span></span>
<span class="line"><span style="color:#D73A49;">var</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">connect</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">function</span><span style="color:#24292E;"> (</span><span style="color:#E36209;">root</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (root </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">traverse</span><span style="color:#24292E;">(root.left, root.right)</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> root</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"><span style="color:#D73A49;">var</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">traverse</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">function</span><span style="color:#24292E;"> (</span><span style="color:#E36209;">treeNode1</span><span style="color:#24292E;">, </span><span style="color:#E36209;">treeNode2</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> ((treeNode1 </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">|</span><span style="color:#24292E;"> (treeNode2 </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">)) </span><span style="color:#D73A49;">return</span></span>
<span class="line"><span style="color:#24292E;">  treeNode1.next </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> treeNode2</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">traverse</span><span style="color:#24292E;">(treeNode1.left, treeNode1.right)</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">traverse</span><span style="color:#24292E;">(treeNode2.left, treeNode2.right)</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">traverse</span><span style="color:#24292E;">(treeNode1.right, treeNode2.left)</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div>`,17),p=[o];function t(r,c,y,E,i,d){return n(),a("div",null,p)}const F=s(e,[["render",t]]);export{u as __pageData,F as default};
